! ! 文字列による１次元的な情報を否定することがKnowdeのコンセプト
! % = self reference = この本自体
! ^ = reference
! ! = knowdeへ反映したいアイデア
! P = 命題
! D = 定義 # 真偽と関係なく何かしらの概念を定める
! ↓ = 例化
! ↑ = 汎化
! ! -> 改行が必要になるような長文を否定
! {} によって用語であることを明示する
! e.g. = 例 # 例化とは違って、具体を書く
  ! ↓ refに要約属性を持たせ、そこに記述すべき内容かも
  !命題セットへの名付け
  ! ListRepo: Ordered, parentからnext関係で接続
  ! ListRepoの操作はUUIDではなく連番を指定するだけで済ませたい
  !   いちいちUUIDを入れるのはメンドイ
  ! SetRepo: Unordered, parentからhas関係で接続
  !   こっちはUUID入れるしかないかも pref_uidでよさげだけど
  ! 命題のview機能
  ! axiom dist = によるview
  ! axiom: premiseを持たない命題
  ! axiom dist: axiomからの距離 axiom -> 0
!こういう文章ファイルからデータを読み込む機能 いちいちコマンド叩いて入力するのも大変
  ! Definitionを表現できるようにDictRepoが欲しいかも
  ! 文章に含まれる名前一覧を表示する
  ! 入力を進めるに際してのサポートが欲しい
  ! 命題セットと文セットの違い
  ! 定義には、真偽の意味合いがない文についての名付けがある
  ! 〜と思い込んだ -> 〜と思い込む　過去形だと出来事っぽい
  ! actorがactionする、という文
  ! a \in actor を明示 述語の実装が要るのか
  ! これらの命題を整理せずに入力し続けると、つまり関連づけをサボると、
  !  premiseがない命題、つまり公理が大量にできる
  !  関連付けの良さが分かるような指標を表示したい
  ! ネットワークを成長させる感覚が欲しい、育成ゲーム的な
  ! Classというprimitiveが要るかも
  ! 旧package構成
  !  /feature_: そのパッケージだけで閉じた基本機能
  !  /shared: どこでも使いわまされるコア機能
  !  /feature: /feature_を利用した機能
  !  直下: /featureを利用した発展的機能とmainが混在
  !  * 旧packageの問題: 境界クラス これは避けられないか
  !      基本単位的なものでもすぐにfeatureに漏れ出してします
  !  新package構成案 4層
  !    /core: 旧shared、グローバルに共有される基本機能
  !    /primitive: 旧feature_
  !    /complex: 高々数個のprimitiveに依存
  !    /feature: /primitiveや/complexに依存する機能
  !refにはない造語 記述量を減らし、関連付けを強化するのに有益な名付け
  ! 定義の文に性質を対応させるようにするのはどうか
  !   同じ定義名が登場する命題を完結に表すために有用だと思う
  !   つまり、主語=同じ定義名を省略できる {self}とでも略記できそう
  ! 以前に定義したもののより詳細が後に記述されてることに対処したい
  ! 即ち、既存のknowde(=知識ノード)を気軽に見つけ出して更新できるようにしたい
  ! 不要な命題 = 他の命題が含意している命題
  ! なんとなくPの紐付けをしているが必ず取りこぼしがあって、
  !   それはaxiomの多さとして表れるはず
  ! 削除しても表現力が下がらないようなPを探す作業が読了後に待っている
  ! 完全に本を理解した -> 任意の本文について関連で言い換えられる
  ! knowdeへの知識入力の手順
  ! - 読みながらメモしてノートをまとめる
  ! knowdeはprimitiveを統一的に扱う
  !   一行の文字列を処理する e.g. 永続化
  ! knowdeの応用としてtextを一括で処理できるようにしたい
  ! 掛け順論争はアプリの宣伝に使えそう
  ! 原因と結果を用語にしようか迷う
  !
  ! 未定義用語とするか否かの判断が難しい
  !   文字数が少なくなるようにするとか
  ! antonym関係: 対義語を表す
  ! 既出の名が用語であることが後で分かる場合がある
  !  登録済みの知識を走査して関連付けたい
  ! 性質のリスト、単なる言明のリスト
  ! statement 単なる言明: 命題ではない文
  !  命題にするには弱いもの、まとめきれないもの、メモとしても使えそう
  ! 整理が弱いとき、公理数が多いこと、関連数の分布にバラツキがあること
  !   などが考えられそう
  ! 定義のツリーを表示する際、重複が現れる場合がある
  !   重複分を表示するのは無駄
  !   定義依存dict[記号, 用語: 説明]というオブジェクトを別途作成する必要がありそう
  ! 具体例と例化の違いは？
  !   例化は関手かも(構造を保った対応付け)
  ! 名前スコープ: 名付けによって生じた特殊文字の有効範囲
  !   特殊文字の例:
  !     {self}: スコープ名
  !     {1}:スコープがlistを持つ場合のlistの1番目
! 文法
!   [文脈]
!
! 本は通常1つの公理系と同一視する
  ! 本書は...というメタ的な内容をどう扱うか
  ! ↑ この表示はCLIの表示として使えそう
  ! つまり、言明や命題はそれとの1階関係を全て表示する
  ! 文脈を行頭に書くのはこれから何を記述するかの意図を強制する良い習慣になり得るかも
  ! WANT: 登録したknowdeを再び入力させるような機能がほしい
  !   記憶の定着を促す練習問題の生成
  ! featureブランチを階層ごとに分けて明示したコミット名にする
  ! featureブランチというgitフローの明示は残したい
  !  e.g. feature/core/source
  ! 言明をもたない文脈D =
  !   用語を持たない => ただのグループ
  !   用語を持つ => Class = 用語を持つグループ
  ! WANT: いちいちCLIで文を書いて入力したくない
  ! WANT: テキストファイルである程度のまとまりを編集したものをCLIに食わせたい
  ! WANT: テキストの文法を考える. 構文論の用語をまとめてみる
  ! WANT: メモの文法もまとめたい
  ! WANT: ある指定した知識をmarkdownのプレーンテキストに変換できる
  ! WANT:   逆変換はなるべくmarkdownに従うが、必ずしも従わない緩い条件にしたい
  !   knowde文形式式: (文脈)?|(用語:)?(文)
  !   token=単語: 構文木の葉、文の最小単位
  !   phrase=句: 文を構成するtokenのまとまり
  !   token class=品詞
  !   主要部: 文法的性質を決める語 <-> 従属関係
  !   述語: 多分"。"で記述されるtokenのまとまり
  !   section=節: 述語と項の組み合わせ
  ! TODO: 構文論の用語がよく分からん。言語学かプログラミングの本を読んで理解を深めたい
  ! TODO: いろいろ読んだ後にknowdeの設計メモをちゃんとまとめよう
  ! 設計の方法論を考える良い機会
  !   設計とは変更しづらいものに関する意思決定だと思う
  !   story: 実現したいことを行動として表す(行動は結果として測定できるためテスト可能)
  !   以後、"STORY:"というprefixを用いる
  !   storyをまず考え抜くことが大事かも
  !     といっても実装のフィードバックによってstory自体を考え直すことがあり得る
  !     だから余り悩みすぎないで手を動かし始める方が良さげ
  ! WANT: これ、knowdeが解決したいものとして書き直せるかも
! REGRET: デジタルなプレーンテキスト以外のメモは再利用しづらい
!  読書メモを紙やデジタルペーパーに書いてきたことが今や無駄なように思う
!  検索性が悪すぎる
!  編集しづらい:
!    紙:
!     - 余白に加筆ができるくらいで、記述の移動や削除などが困難
!     - 紙が劣化するし、文字が滲む
!    デジタルペーパー:
!     - 一括置換などできないし、検索もできない
!     - ブログなどに転用(コピペ)できないからマネタイズに繋がりにくい
! 自動翻訳: 文を入力したら関係を推論してくれる
  !   用語サジェスト
  !   文が何を表すかで場合分けが要るかも (共通処理もあるだろうけど)
! WANT: articleというデータ型: .mdを自動生成・削除・更新する単位
!   これができれば、記事にまとめるというハードルを低くできる
!   一つ一つの知識を記述するのはハードル低い
!   ある主張の記事をまとめるのはかなり大変
  ! WANT: knowdeをvimから操作 knowde.vim
  ! WANT: CLIで標準入力を扱う
  ! 名前空間: 用語の有効範囲を決める辞書
  ! sourceは暗黙に名前空間を作成する
  ! 名前空間の結合
  !    衝突を
  !      許容する場合: 用語サジェストの範囲を広げたい場合
  !      <-> 許容しない場合:
  !
  ! 複数文を食わせた結果のフィードバック
  !   parse要素数:
  !     空文の場合 0
  !     文脈が足りていないなどの文法不整合数
  !   lexical analyze 字句解析    トークンに分解
  !   parser トークンから意味を取り出す
  ! 用語の同値類のようなものでエイリアスを表現できそう
  !   でもエイリアスがある事自体は明晰さを欠くかも
  !   用語に対応する英語を１つ書けるくらいに留めるべきか
  D_21 |記号=言語=言葉: 観念を観察可能にする表象 !# 自作定義
  P_21 |どんな観念を作り出すにも{言語}が必要 !# 類のこと？
  ! 情報源は用語が統一されている単位のはず
  ! 文脈のIDの評価:
  !   P??とかD??とかで知識単位の種類と同一性を明示しているが、
  !     まずparse時にそれらが整合しているかのチェックがしたい
  !       定義されてないIDを参照していないか
  ! 文字総数は整理度の指標に使えるかも
  !# TODO: 推論の形を整理せよ
  ! webアプリは文脈の連番を自動生成するようにしたいかも
  !   プレーンテキストでの文脈振りはメンドイ
  ! 知識の登録時に紐付けの抜け漏れがないか診断したい
  !   -> 知識の一括登録は逐次的に行われ、都度診断のために利用するデータが増える
  ! システムが扱う知識の構造を分析するためには
  !   書いてみて観察するしかない
  ! 命題とかいらない気がしてきた 全部statementで良い
  ! となると、命題文脈Pは用語と同じ
  !   もっと気軽に書けるようにすべきかも
  ! twitterの140文字制限を真似るか
  ! 対義語を表す関係を永続化したい
  ! 用語のローカルスコープ
  ! 用語の拡張: 別の言明から参照することを意図しないローカルスコープの用語
  ! 用語の衝突チェック: ローカル用語であっても、同じものが乱立するのは良くないと思う
  !   衝突レベルを指定して処理できると柔軟で良さげ
  ! セクション直下間では衝突するようにすべし
  !   １つの本という一貫性を強制したい
  !   衝突があったこと自体は記録したいかも
  !     どこから引用したかの手がかりになる.
  ! DBに依存しない形、プレーンテキストの読み書きだけでも
  !   全てのストーリーが実現できるはず
  !   まずはその単純なバージョンから作るのも悪くない
  !   APIも作らなくて良くて楽
  ! load プレーンテキストからメモリへ読み取る
  ! save メモリ上のデータを永続化する
  ! eat プレーンテキスト->メモリ->DB
  ! primitive テキストとしての表現を持つ
  !   namespace
  !   name
  !   scope: インデントの単位
  ! InMemory in /complex primitiveの複合, saveできる
! 章の題名が長過ぎる。副題を持たせられるようにするか
! 章分けのデメリット
!   既出の用語が繰り返し説明されていて散らばる
  <!-- 見積もりのコツ: {不確実性コーン}はあれど予算もいるし避けられない -->
  ! 一致率: 名称や言明の依存関係を突き合わせるときに、記述ミスを検出・予想したい
  ! まずはメモ整理の支援ができる機能
  ! YAMLやJSONなどにも対応したいかも
  ! 要約を生成できる
  !   何が重要なのかが分かる
  ! 用語文字数や言明文字数の総数を把握する
  !   よいまとまりの指標
